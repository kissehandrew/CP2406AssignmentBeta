package com.example.cp2406assignmentbeta;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVRecord;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;

/**
 * CP2406 Assignment Rainfall Analyser Beta class - Andrew Kisseh
 * Use the Apache CSV package and the RainfallRecord & MonthlyRainfallData Class
 */
public class RainfallAnalyser {

    public RainfallRecord analyseRainfallData(String path) throws Exception {
        // Check if the file is empty
        File f = new File(path);
        if (f.length() == 0)
            throw new Exception("That file is empty");

        RainfallRecord newRainfallRecord = new RainfallRecord();
        newRainfallRecord.setFilename(path);

        // Create the FileReader and CSV reader
        // See https://commons.apache.org/proper/commons-csv/
        Reader reader = new FileReader(path);
        Iterable<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(reader);

        int year, month, day;
        double rainfall;
        int currentYear = 0;
        int currentMonth = 1;
        double monthlyTotal = 0.0;
        double minRainfall = Double.POSITIVE_INFINITY;
        double maxRainfall = 0.0;
        boolean startReadingData = false;

        for (CSVRecord record : records) {
            // Get data from particular columns of rainfalldata csv file
            String yearText = record.get("Year");
            String monthText = record.get("Month");
            String dayText = record.get("Day");
            String rainfallText = record.get("Rainfall amount (millimetres)");

            // Check if there is data for rainfall
            if (rainfallText.isEmpty()) {
                continue; // If the entry is empty, ignore it and move to the next entry
            } else {
                rainfall = Double.parseDouble(rainfallText);

                // covert data in appropriate data types
                // and validate recorded date
                year = Integer.parseInt(yearText);
                month = Integer.parseInt(monthText);
                day = Integer.parseInt(dayText);
                if ((month < 1 || month > 12) || (day < 1 || day > 31)) {
                    throw new NumberFormatException("Dates are out of expected range");
                }
            }

            // Check if it's the next month
            if (month != currentMonth) {
                // Ignore initial null values for rainfall
                if (!startReadingData) {
                    startReadingData = true;
                } else {
                    newRainfallRecord.addRainfallData(monthlyTotal, minRainfall, maxRainfall, currentMonth, currentYear == 0 ? year : currentYear);
                }
                currentYear = year;
                currentMonth = month;
                monthlyTotal = 0;
                maxRainfall = 0.0;
                minRainfall = Double.POSITIVE_INFINITY;
            }

            // Update the total for the month
            monthlyTotal += rainfall;
            if (rainfall > maxRainfall) maxRainfall = rainfall;
            if (rainfall < minRainfall) minRainfall = rainfall;
        }
        // Catch incomplete month when exiting the for loop
        newRainfallRecord.addRainfallData(monthlyTotal, minRainfall, maxRainfall, currentMonth, currentYear);

        return newRainfallRecord;

    }


    /**
     * Creates a RainfallRecord object from a previously analysed file.
     * Because the supplied file should only be generated by this Rainfall Analyser class
     * there is no need to check whether the parse methods will fail.
     */
    public RainfallRecord getAnalysedRainfallData(String path) throws IOException {
        RainfallRecord rainfallRecord = new RainfallRecord();
        rainfallRecord.setFilename(path);
        Reader reader = new FileReader(path);
        Iterable<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(reader);

        for (CSVRecord record : records) {
            int year = Integer.parseInt(record.get("year"));
            int month = Integer.parseInt(record.get("month"));
            double total = Double.parseDouble(record.get("total"));
            double min = Double.parseDouble(record.get("minimum"));
            double max = Double.parseDouble(record.get("maximum"));

            rainfallRecord.addRainfallData(total, min, max, month, year);
        }
        return rainfallRecord;
    }

    public String saveRainfallData(RainfallRecord rainfallRecord) {
        if (rainfallRecord.getFilename() == null) {
            return null;
        }
        String savePath = "src/main/resources/analysedrainfalldata/" + rainfallRecord.getFilename();
        TextIO.writeFile(savePath);
        TextIO.putln("year,month,total,minimum,maximum");
        for (MonthlyRainfallData monthlyRainfallData : rainfallRecord.getRainfallData()) {
            TextIO.putf("%d,%d,%1.2f,%1.2f,%1.2f\n",
                    monthlyRainfallData.getYear(), monthlyRainfallData.getMonth(), monthlyRainfallData.getTotal(),
                    monthlyRainfallData.getMin(), monthlyRainfallData.getMax());
        }
        return rainfallRecord.getFilename();
    }
}
